ARM GAS  /tmp/ccWOMrG1.s 			page 1


   1              		.cpu cortex-m7
   2              		.arch armv7e-m
   3              		.fpu fpv5-d16
   4              		.eabi_attribute 28, 1
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.file	"protocol.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.file 1 "protocol.c"
  19              		.section	.text.send_ack,"ax",%progbits
  20              		.align	1
  21              		.syntax unified
  22              		.thumb
  23              		.thumb_func
  25              	send_ack:
  26              	.LFB336:
   1:protocol.c    **** /*******************************************************************************
   2:protocol.c    **** *
   3:protocol.c    **** * FILE: 
   4:protocol.c    **** * 		protocol.c
   5:protocol.c    **** *
   6:protocol.c    **** * DESCRIPTION: 
   7:protocol.c    **** * 	    Implements a protocol for communicating with the ground station over 
   8:protocol.c    **** *       the wireless interface 
   9:protocol.c    **** *
  10:protocol.c    **** *******************************************************************************/
  11:protocol.c    **** 
  12:protocol.c    **** 
  13:protocol.c    **** /*------------------------------------------------------------------------------
  14:protocol.c    ****  Standard Includes                                                              
  15:protocol.c    **** ------------------------------------------------------------------------------*/
  16:protocol.c    **** #include <string.h>
  17:protocol.c    **** #include <stdbool.h>
  18:protocol.c    **** 
  19:protocol.c    **** 
  20:protocol.c    **** /*------------------------------------------------------------------------------
  21:protocol.c    ****  Project Includes                                                              
  22:protocol.c    **** ------------------------------------------------------------------------------*/
  23:protocol.c    **** 
  24:protocol.c    **** /* Application level */
  25:protocol.c    **** #include "main.h"
  26:protocol.c    **** #include "valve_control.h"
  27:protocol.c    **** #include "protocol.h"
  28:protocol.c    **** 
  29:protocol.c    **** /* Module level */
  30:protocol.c    **** #include "commands.h"
  31:protocol.c    **** #include "led.h"
  32:protocol.c    **** #include "rs485.h"
ARM GAS  /tmp/ccWOMrG1.s 			page 2


  33:protocol.c    **** #include "sensor.h"
  34:protocol.c    **** #include "solenoid.h"
  35:protocol.c    **** #include "valve.h"
  36:protocol.c    **** #include "wireless.h"
  37:protocol.c    **** 
  38:protocol.c    **** 
  39:protocol.c    **** /*------------------------------------------------------------------------------
  40:protocol.c    ****  Function Prototypes 
  41:protocol.c    **** ------------------------------------------------------------------------------*/
  42:protocol.c    **** 
  43:protocol.c    **** /* Sends a signal to the PC that engine controller is responsive */
  44:protocol.c    **** static void send_ack
  45:protocol.c    **** 	(
  46:protocol.c    **** 	void
  47:protocol.c    **** 	);
  48:protocol.c    **** 
  49:protocol.c    **** /*------------------------------------------------------------------------------
  50:protocol.c    ****  Global Variables 
  51:protocol.c    **** ------------------------------------------------------------------------------*/
  52:protocol.c    **** extern volatile FSM_STATE fsm_state;           /* State of engine hotfire     */
  53:protocol.c    **** extern volatile bool      stop_hotfire_flag;   /* Manual hotfire termination  */
  54:protocol.c    **** extern volatile bool      stop_purge_flag;     /* Manual purge termination    */
  55:protocol.c    **** extern volatile bool      lox_purge_flag;      /* LOX tank purge              */
  56:protocol.c    **** extern volatile bool      kbottle_closed_flag; /* Kbottle is closed           */
  57:protocol.c    **** extern volatile bool      tanks_safe_flag;     /* Safe tank pressures         */
  58:protocol.c    **** extern volatile bool      telreq_wait_flag;    /* Wait flag for telreq cmds   */
  59:protocol.c    **** extern SENSOR_DATA_PING_PONG sensor_ping_pong_buffer;
  60:protocol.c    **** 
  61:protocol.c    **** 
  62:protocol.c    **** /*------------------------------------------------------------------------------
  63:protocol.c    ****  Public Functions 
  64:protocol.c    **** ------------------------------------------------------------------------------*/
  65:protocol.c    **** 
  66:protocol.c    **** 
  67:protocol.c    **** /*******************************************************************************
  68:protocol.c    **** *                                                                              *
  69:protocol.c    **** * PROCEDURE:                                                                   *
  70:protocol.c    **** * 		protocol_command_handler                                               *
  71:protocol.c    **** *                                                                              *
  72:protocol.c    **** * DESCRIPTION:                                                                 *
  73:protocol.c    **** *       Handles commands received from the ground station                      *
  74:protocol.c    **** *                                                                              *
  75:protocol.c    **** *******************************************************************************/
  76:protocol.c    **** void protocol_command_handler
  77:protocol.c    ****     (
  78:protocol.c    ****     uint8_t command /* Ground station command */
  79:protocol.c    ****     )
  80:protocol.c    **** {
  81:protocol.c    **** /*------------------------------------------------------------------------------
  82:protocol.c    ****  Local Variables  
  83:protocol.c    **** ------------------------------------------------------------------------------*/
  84:protocol.c    **** uint8_t          subcommand;                  /* SDEC subcommand              */
  85:protocol.c    **** uint8_t          sol_state;                   /* State of solenoids           */
  86:protocol.c    **** SENSOR_DATA      sensor_data;                 /* Data from engine sensors     */
  87:protocol.c    **** uint8_t          sensor_data_bytes[ sizeof( SENSOR_DATA ) ]; 
  88:protocol.c    **** RS485_STATUS     rs485_status;                /* RS485 return codes           */
  89:protocol.c    **** VALVE_STATUS     valve_status;                /* Valve module return codes    */
ARM GAS  /tmp/ccWOMrG1.s 			page 3


  90:protocol.c    **** TANK_SAFE_STATES tanks_state;                 /* State of tank pressures      */
  91:protocol.c    **** VALVE_STATES     valve_states;                /* Open/close state of valves   */
  92:protocol.c    **** 
  93:protocol.c    **** 
  94:protocol.c    **** /*------------------------------------------------------------------------------
  95:protocol.c    ****  Initializations 
  96:protocol.c    **** ------------------------------------------------------------------------------*/
  97:protocol.c    **** rs485_status  = RS485_OK;
  98:protocol.c    **** valve_status  = VALVE_OK;
  99:protocol.c    **** valve_states  = 0;
 100:protocol.c    **** sol_state     = 0;
 101:protocol.c    **** memset( &sensor_data         , 0, sizeof( sensor_data       ) );
 102:protocol.c    **** memset( &sensor_data_bytes[0], 0, sizeof( sensor_data_bytes ) );
 103:protocol.c    **** 
 104:protocol.c    **** 
 105:protocol.c    **** /*------------------------------------------------------------------------------
 106:protocol.c    ****  Command Handling 
 107:protocol.c    **** ------------------------------------------------------------------------------*/
 108:protocol.c    **** switch( command )
 109:protocol.c    ****     {
 110:protocol.c    ****     /*--------------------------------------------------------------------------
 111:protocol.c    ****      PING Command	
 112:protocol.c    ****     --------------------------------------------------------------------------*/
 113:protocol.c    ****     case PING_OP:
 114:protocol.c    ****         {
 115:protocol.c    ****         ping();
 116:protocol.c    ****         break;
 117:protocol.c    ****         } /* PING_OP */
 118:protocol.c    **** 
 119:protocol.c    ****     /*--------------------------------------------------------------------------
 120:protocol.c    ****      CONNECT Command	
 121:protocol.c    ****     --------------------------------------------------------------------------*/
 122:protocol.c    ****     case CONNECT_OP:
 123:protocol.c    ****         {
 124:protocol.c    ****         ping();
 125:protocol.c    ****         break;
 126:protocol.c    ****         } /* CONNECT_OP */
 127:protocol.c    ****     
 128:protocol.c    ****     /*--------------------------------------------------------------------------
 129:protocol.c    ****      SOL Command	
 130:protocol.c    ****     --------------------------------------------------------------------------*/
 131:protocol.c    ****     case SOL_OP:
 132:protocol.c    ****         {
 133:protocol.c    ****         /* Get subcommand */
 134:protocol.c    ****         rs485_status = rs485_receive( &subcommand         , 
 135:protocol.c    ****                                       sizeof( subcommand ), 
 136:protocol.c    ****                                       RS485_DEFAULT_TIMEOUT );
 137:protocol.c    ****         if ( rs485_status != RS485_OK )
 138:protocol.c    ****             {
 139:protocol.c    ****             led_set_color( LED_YELLOW );
 140:protocol.c    ****             break;
 141:protocol.c    ****             }
 142:protocol.c    ****         
 143:protocol.c    ****         /* Pass on command and subcommand to valve controller */ 
 144:protocol.c    ****         valve_transmit( &command   , sizeof( command ), HAL_DEFAULT_TIMEOUT );
 145:protocol.c    ****         valve_transmit( &subcommand, sizeof( command ), HAL_DEFAULT_TIMEOUT );
 146:protocol.c    **** 
ARM GAS  /tmp/ccWOMrG1.s 			page 4


 147:protocol.c    ****         /* Pass on valve state if sol getstate command */
 148:protocol.c    ****         if ( subcommand == SOL_GETSTATE_CODE )
 149:protocol.c    ****             {
 150:protocol.c    ****             valve_status = valve_receive( &sol_state, 
 151:protocol.c    ****                                           sizeof( sol_state ), 
 152:protocol.c    ****                                           HAL_DEFAULT_TIMEOUT );
 153:protocol.c    ****             if ( valve_status != VALVE_OK )
 154:protocol.c    ****                 {
 155:protocol.c    ****                 led_set_color( LED_YELLOW );
 156:protocol.c    ****                 break;
 157:protocol.c    ****                 }
 158:protocol.c    ****             rs485_transmit( &sol_state, sizeof( sol_state ), HAL_DEFAULT_TIMEOUT );
 159:protocol.c    ****             }
 160:protocol.c    ****         break;
 161:protocol.c    ****         } /* SOL_OP */
 162:protocol.c    **** 
 163:protocol.c    ****     /*--------------------------------------------------------------------------
 164:protocol.c    ****      VALVE Command	
 165:protocol.c    ****     --------------------------------------------------------------------------*/
 166:protocol.c    ****     case VALVE_OP:
 167:protocol.c    ****         {
 168:protocol.c    ****         /* Get subcommand */
 169:protocol.c    ****         rs485_status = rs485_receive( &subcommand         , 
 170:protocol.c    ****                                       sizeof( subcommand ), 
 171:protocol.c    ****                                       RS485_DEFAULT_TIMEOUT );
 172:protocol.c    ****         if ( rs485_status != RS485_OK )
 173:protocol.c    ****             {
 174:protocol.c    ****             led_set_color( LED_YELLOW );
 175:protocol.c    ****             break;
 176:protocol.c    ****             }
 177:protocol.c    **** 
 178:protocol.c    ****         /* Pass on command and subcommand to valve controller */ 
 179:protocol.c    ****         valve_transmit( &command   , sizeof( command ), HAL_DEFAULT_TIMEOUT );
 180:protocol.c    ****         valve_transmit( &subcommand, sizeof( command ), HAL_DEFAULT_TIMEOUT );
 181:protocol.c    ****         break;
 182:protocol.c    ****         } /* VALVE_OP */
 183:protocol.c    **** 
 184:protocol.c    ****     /*--------------------------------------------------------------------------
 185:protocol.c    ****      ABORT Command	
 186:protocol.c    ****     --------------------------------------------------------------------------*/
 187:protocol.c    ****     case ABORT_OP:
 188:protocol.c    ****         {
 189:protocol.c    ****         /* Send ACK signal */
 190:protocol.c    ****         send_ack();
 191:protocol.c    **** 
 192:protocol.c    ****         /* Initiate Abort */
 193:protocol.c    ****         run_abort_state();
 194:protocol.c    ****         fsm_state = FSM_ABORT_STATE;
 195:protocol.c    ****         break;
 196:protocol.c    ****         } /* ABORT_OP */
 197:protocol.c    **** 
 198:protocol.c    ****     /*--------------------------------------------------------------------------
 199:protocol.c    ****      TELREQ Command	
 200:protocol.c    ****     --------------------------------------------------------------------------*/
 201:protocol.c    ****     case TELREQ_OP:
 202:protocol.c    ****         {
 203:protocol.c    ****         /* Send ACK */
ARM GAS  /tmp/ccWOMrG1.s 			page 5


 204:protocol.c    ****         send_ack();
 205:protocol.c    **** 
 206:protocol.c    ****         /* Get sensor data */
 207:protocol.c    ****         sensor_dump( &sensor_data );
 208:protocol.c    ****         memcpy( &sensor_data_bytes[0], &sensor_data, sizeof( SENSOR_DATA ) );
 209:protocol.c    **** 
 210:protocol.c    ****         /* Get the state of the valves */
 211:protocol.c    ****         vc_getstate( &valve_states );
 212:protocol.c    **** 
 213:protocol.c    ****         /* Transmit the sensor and valve data */
 214:protocol.c    ****         rs485_transmit( &sensor_data_bytes[0], 
 215:protocol.c    ****                         sizeof( SENSOR_DATA ), 
 216:protocol.c    ****                         RS485_DEFAULT_TIMEOUT*sizeof( SENSOR_DATA ));
 217:protocol.c    ****         rs485_transmit( &valve_states         , 
 218:protocol.c    ****                         sizeof( valve_states ), 
 219:protocol.c    ****                         RS485_DEFAULT_TIMEOUT );
 220:protocol.c    ****         break;
 221:protocol.c    ****         } /* TELREQ_OP */
 222:protocol.c    **** 
 223:protocol.c    ****     /*--------------------------------------------------------------------------
 224:protocol.c    ****      PFPURGE Command	
 225:protocol.c    ****     --------------------------------------------------------------------------*/
 226:protocol.c    ****     case PFPURGE_OP:
 227:protocol.c    ****         {
 228:protocol.c    ****         /* Send ACK signal */
 229:protocol.c    ****         send_ack();
 230:protocol.c    **** 
 231:protocol.c    ****         /* Initiate Purge*/
 232:protocol.c    ****         fsm_state = FSM_PRE_FIRE_PURGE_STATE;
 233:protocol.c    ****         break;
 234:protocol.c    ****         } /* PFPURGE_OP */
 235:protocol.c    ****     
 236:protocol.c    ****     /*--------------------------------------------------------------------------
 237:protocol.c    ****      CHILL Command	
 238:protocol.c    ****     --------------------------------------------------------------------------*/
 239:protocol.c    ****     case CHILL_OP:
 240:protocol.c    ****         {
 241:protocol.c    ****         /* Send ACK signal */
 242:protocol.c    ****         send_ack();
 243:protocol.c    **** 
 244:protocol.c    ****         /* Initiate Fill and Chill Sequence */
 245:protocol.c    ****         fsm_state = FSM_FILL_CHILL_STATE;
 246:protocol.c    ****         break;
 247:protocol.c    ****         } /* CHILL_OP */
 248:protocol.c    **** 
 249:protocol.c    ****     /*--------------------------------------------------------------------------
 250:protocol.c    ****      STANDBY Command	
 251:protocol.c    ****     --------------------------------------------------------------------------*/
 252:protocol.c    ****     case STANDBY_OP:
 253:protocol.c    ****         {
 254:protocol.c    ****         /* Send ACK signal */
 255:protocol.c    ****         send_ack();
 256:protocol.c    **** 
 257:protocol.c    ****         /* Initiate Standby mode */
 258:protocol.c    ****         fsm_state = FSM_STANDBY_STATE;
 259:protocol.c    ****         break;
 260:protocol.c    ****         } /* STANDBY_OP */
ARM GAS  /tmp/ccWOMrG1.s 			page 6


 261:protocol.c    **** 
 262:protocol.c    ****     /*--------------------------------------------------------------------------
 263:protocol.c    ****      FIRE Command 
 264:protocol.c    ****     --------------------------------------------------------------------------*/
 265:protocol.c    ****     case FIRE_OP:
 266:protocol.c    ****         {
 267:protocol.c    ****         /* Send ACK signal */
 268:protocol.c    ****         send_ack();
 269:protocol.c    **** 
 270:protocol.c    ****         /* Initiate Standby mode */
 271:protocol.c    ****         fsm_state = FSM_FIRE_STATE;
 272:protocol.c    ****         break;
 273:protocol.c    ****         } /* FIRE_OP */
 274:protocol.c    **** 
 275:protocol.c    ****     /*--------------------------------------------------------------------------
 276:protocol.c    ****      STOPPURGE Command 
 277:protocol.c    ****     --------------------------------------------------------------------------*/
 278:protocol.c    ****     case STOPPURGE_OP:
 279:protocol.c    ****         {
 280:protocol.c    ****         /* Send ACK signal */
 281:protocol.c    ****         send_ack();
 282:protocol.c    **** 
 283:protocol.c    ****         /* Stop the engine purge */
 284:protocol.c    ****         stop_purge_flag = true;
 285:protocol.c    ****         break;
 286:protocol.c    ****         } /* STOPPURGE_OP */
 287:protocol.c    **** 
 288:protocol.c    ****     /*--------------------------------------------------------------------------
 289:protocol.c    ****      GETSTATE Command 
 290:protocol.c    ****     --------------------------------------------------------------------------*/
 291:protocol.c    ****     case HOTFIRE_GETSTATE_OP:
 292:protocol.c    ****         {
 293:protocol.c    ****         /* Send the finite state machine state back to the ground station */
 294:protocol.c    ****         rs485_transmit( (void*) &fsm_state, sizeof( fsm_state ), RS485_DEFAULT_TIMEOUT );
 295:protocol.c    ****         break;
 296:protocol.c    ****         } /* HOTFIRE_GETSTATE_OP */
 297:protocol.c    **** 
 298:protocol.c    ****     /*--------------------------------------------------------------------------
 299:protocol.c    ****      STOPHOTFIRE Command 
 300:protocol.c    ****     --------------------------------------------------------------------------*/
 301:protocol.c    ****     case STOP_HOTFIRE_OP:
 302:protocol.c    ****         {
 303:protocol.c    ****         /* Send ACK signal */
 304:protocol.c    ****         send_ack();
 305:protocol.c    **** 
 306:protocol.c    ****         /* Set the stop hotfire flag */
 307:protocol.c    ****         stop_hotfire_flag = true;
 308:protocol.c    ****         break;
 309:protocol.c    ****         } /* STOP_HOTFIRE_OP */
 310:protocol.c    **** 
 311:protocol.c    ****     /*--------------------------------------------------------------------------
 312:protocol.c    ****      LOXPURGE Command 
 313:protocol.c    ****     --------------------------------------------------------------------------*/
 314:protocol.c    ****     case LOX_PURGE_OP:
 315:protocol.c    ****         {
 316:protocol.c    ****         /* Send ACK signal */
 317:protocol.c    ****         send_ack();
ARM GAS  /tmp/ccWOMrG1.s 			page 7


 318:protocol.c    **** 
 319:protocol.c    ****         /* Set the lox purge flag */
 320:protocol.c    ****         lox_purge_flag = true;
 321:protocol.c    ****         break;
 322:protocol.c    ****         } /* LOX_PURGE_OP */
 323:protocol.c    ****     
 324:protocol.c    ****     /*--------------------------------------------------------------------------
 325:protocol.c    ****      KBOTTLE Command 
 326:protocol.c    ****     --------------------------------------------------------------------------*/
 327:protocol.c    ****     case KBOTTLE_CLOSED_OP:
 328:protocol.c    ****         {
 329:protocol.c    ****         /* Send ACK signal */
 330:protocol.c    ****         send_ack();
 331:protocol.c    **** 
 332:protocol.c    ****         /* Set the kbottle closed flag */
 333:protocol.c    ****         kbottle_closed_flag = true;
 334:protocol.c    ****         break;
 335:protocol.c    ****         } /* KBOTTLE_CLOSED_OP */
 336:protocol.c    **** 
 337:protocol.c    ****     /*--------------------------------------------------------------------------
 338:protocol.c    ****      TANKSTAT Command 
 339:protocol.c    ****     --------------------------------------------------------------------------*/
 340:protocol.c    ****     case TANKSTAT_OP:
 341:protocol.c    ****         {
 342:protocol.c    ****         /* Check flags */
 343:protocol.c    ****         if ( tanks_safe_flag )
 344:protocol.c    ****             {
 345:protocol.c    ****             tanks_state = TANKS_SAFE;
 346:protocol.c    ****             }
 347:protocol.c    ****         else
 348:protocol.c    ****             {
 349:protocol.c    ****             tanks_state = TANKS_UNSAFE;
 350:protocol.c    ****             }
 351:protocol.c    ****         
 352:protocol.c    ****         /* Send response */
 353:protocol.c    ****         rs485_transmit( &tanks_state, sizeof( tanks_state ), RS485_DEFAULT_TIMEOUT );
 354:protocol.c    ****         break;
 355:protocol.c    ****         }
 356:protocol.c    **** 
 357:protocol.c    ****     /*--------------------------------------------------------------------------
 358:protocol.c    ****      MANUAL Command 
 359:protocol.c    ****     --------------------------------------------------------------------------*/
 360:protocol.c    ****     case MANUAL_OP:
 361:protocol.c    ****         {
 362:protocol.c    ****         /* Send ACK signal */
 363:protocol.c    ****         send_ack();
 364:protocol.c    **** 
 365:protocol.c    ****         /* Set the kbottle closed flag */
 366:protocol.c    ****         fsm_state = FSM_MANUAL_STATE;
 367:protocol.c    ****         break;
 368:protocol.c    ****         } /* KBOTTLE_CLOSED_OP */
 369:protocol.c    **** 
 370:protocol.c    ****     /*--------------------------------------------------------------------------
 371:protocol.c    ****      Unrecognized Command 
 372:protocol.c    ****     --------------------------------------------------------------------------*/
 373:protocol.c    ****     default:
 374:protocol.c    ****         {
ARM GAS  /tmp/ccWOMrG1.s 			page 8


 375:protocol.c    ****         /* Unsupported command code flash the red LED */
 376:protocol.c    ****         //Error_Handler();
 377:protocol.c    ****         } /* default */
 378:protocol.c    ****     } 
 379:protocol.c    **** 
 380:protocol.c    **** } /* protocol_command_handler */
 381:protocol.c    **** 
 382:protocol.c    **** 
 383:protocol.c    **** /*******************************************************************************
 384:protocol.c    **** *                                                                              *
 385:protocol.c    **** * PROCEDURE:                                                                   *
 386:protocol.c    **** * 		protocol_send_frame                                                    *
 387:protocol.c    **** *                                                                              *
 388:protocol.c    **** * DESCRIPTION:                                                                 *
 389:protocol.c    **** *       Send a frame of data over the long-range communication interface       *
 390:protocol.c    **** *                                                                              *
 391:protocol.c    **** *******************************************************************************/
 392:protocol.c    **** PROTOCOL_STATUS protocol_send_frame
 393:protocol.c    ****     (
 394:protocol.c    ****     PROTOCOL_FRAME frame
 395:protocol.c    ****     )
 396:protocol.c    **** {
 397:protocol.c    **** /*------------------------------------------------------------------------------
 398:protocol.c    ****  Local Variables 
 399:protocol.c    **** ------------------------------------------------------------------------------*/
 400:protocol.c    **** #ifdef USE_RS485
 401:protocol.c    ****     RS485_STATUS rs485_status;
 402:protocol.c    **** #else
 403:protocol.c    ****     RF_STATUS    rf_status;
 404:protocol.c    **** #endif
 405:protocol.c    **** 
 406:protocol.c    **** 
 407:protocol.c    **** /*------------------------------------------------------------------------------
 408:protocol.c    ****  Initializations 
 409:protocol.c    **** ------------------------------------------------------------------------------*/
 410:protocol.c    **** #ifdef USE_RS485
 411:protocol.c    ****     rs485_status = RS485_OK;
 412:protocol.c    **** #else
 413:protocol.c    ****     rf_status    = RF_OK;
 414:protocol.c    **** #endif
 415:protocol.c    **** 
 416:protocol.c    **** 
 417:protocol.c    **** /*------------------------------------------------------------------------------
 418:protocol.c    ****  Implementation
 419:protocol.c    **** ------------------------------------------------------------------------------*/
 420:protocol.c    **** #ifdef USE_RS485
 421:protocol.c    ****     rs485_status = rs485_transmit( &frame, 
 422:protocol.c    ****                                    sizeof( frame ), 
 423:protocol.c    ****                                    RS485_DEFAULT_TIMEOUT*sizeof( frame ) );
 424:protocol.c    ****     if ( rs485_status == RS485_TIMEOUT )
 425:protocol.c    ****         {
 426:protocol.c    ****         return PROTOCOL_TIMEOUT;
 427:protocol.c    ****         }
 428:protocol.c    ****     else if ( rs485_status != RS485_OK )
 429:protocol.c    ****         {
 430:protocol.c    ****         return PROTOCOL_ERROR;
 431:protocol.c    ****         }
ARM GAS  /tmp/ccWOMrG1.s 			page 9


 432:protocol.c    **** #else
 433:protocol.c    ****     rf_status = rf_xbee_transmit( &frame, sizeof( frame ) );
 434:protocol.c    ****     if ( rf_status == RF_TIMEOUT )
 435:protocol.c    ****         {
 436:protocol.c    ****         return PROTOCOL_TIMEOUT;
 437:protocol.c    ****         }
 438:protocol.c    ****     else if ( rf_status != RF_OK )
 439:protocol.c    ****         {
 440:protocol.c    ****         return RF_ERROR;
 441:protocol.c    ****         }
 442:protocol.c    **** #endif
 443:protocol.c    **** 
 444:protocol.c    **** return PROTOCOL_OK;
 445:protocol.c    **** } /* protocol_send_frame */
 446:protocol.c    **** 
 447:protocol.c    **** 
 448:protocol.c    **** /*******************************************************************************
 449:protocol.c    **** *                                                                              *
 450:protocol.c    **** * PROCEDURE:                                                                   *
 451:protocol.c    **** * 		protocol_get_frame                                                     *
 452:protocol.c    **** *                                                                              *
 453:protocol.c    **** * DESCRIPTION:                                                                 *
 454:protocol.c    **** *       Get a frame of data over the long-range communication interface        *
 455:protocol.c    **** *                                                                              *
 456:protocol.c    **** *******************************************************************************/
 457:protocol.c    **** PROTOCOL_STATUS protocol_get_frame
 458:protocol.c    ****     (
 459:protocol.c    ****     PROTOCOL_FRAME* frame_ptr
 460:protocol.c    ****     )
 461:protocol.c    **** {
 462:protocol.c    **** /*------------------------------------------------------------------------------
 463:protocol.c    ****  Local Variables 
 464:protocol.c    **** ------------------------------------------------------------------------------*/
 465:protocol.c    **** #ifdef USE_RS485
 466:protocol.c    ****     RS485_STATUS rs485_status;
 467:protocol.c    **** #else
 468:protocol.c    ****     RF_STATUS    rf_status;
 469:protocol.c    **** #endif
 470:protocol.c    **** 
 471:protocol.c    **** 
 472:protocol.c    **** /*------------------------------------------------------------------------------
 473:protocol.c    ****  Initializations 
 474:protocol.c    **** ------------------------------------------------------------------------------*/
 475:protocol.c    **** #ifdef USE_RS485
 476:protocol.c    ****     rs485_status = RS485_OK;
 477:protocol.c    **** #else
 478:protocol.c    ****     rf_status    = RF_OK;
 479:protocol.c    **** #endif
 480:protocol.c    **** 
 481:protocol.c    **** 
 482:protocol.c    **** /*------------------------------------------------------------------------------
 483:protocol.c    ****  Implementation
 484:protocol.c    **** ------------------------------------------------------------------------------*/
 485:protocol.c    **** #ifdef USE_RS485
 486:protocol.c    ****     rs485_status = rs485_receive( frame_ptr, 
 487:protocol.c    ****                                   sizeof( PROTOCOL_FRAME ), 
 488:protocol.c    ****                                   RS485_DEFAULT_TIMEOUT*sizeof( PROTOCOL_FRAME) );
ARM GAS  /tmp/ccWOMrG1.s 			page 10


 489:protocol.c    ****     if ( rs485_status == RS485_TIMEOUT )
 490:protocol.c    ****         {
 491:protocol.c    ****         return PROTOCOL_TIMEOUT;
 492:protocol.c    ****         }
 493:protocol.c    ****     else if ( rs485_status != RS485_OK )
 494:protocol.c    ****         {
 495:protocol.c    ****         return PROTOCOL_ERROR;
 496:protocol.c    ****         }
 497:protocol.c    **** #else
 498:protocol.c    ****     rf_status = rf_xbee_receive( frame_ptr, sizeof( PROTOCOL_FRAME ) );
 499:protocol.c    ****     if ( rf_status == RF_TIMEOUT )
 500:protocol.c    ****         {
 501:protocol.c    ****         return PROTOCOL_TIMEOUT;
 502:protocol.c    ****         }
 503:protocol.c    ****     else if ( rf_status != RF_OK )
 504:protocol.c    ****         {
 505:protocol.c    ****         return RF_ERROR;
 506:protocol.c    ****         }
 507:protocol.c    **** #endif
 508:protocol.c    **** 
 509:protocol.c    **** return PROTOCOL_OK;
 510:protocol.c    **** } /* protocol_get_frame */
 511:protocol.c    **** 
 512:protocol.c    **** 
 513:protocol.c    **** /*------------------------------------------------------------------------------
 514:protocol.c    ****  Internal Functions 
 515:protocol.c    **** ------------------------------------------------------------------------------*/
 516:protocol.c    **** 
 517:protocol.c    **** /*******************************************************************************
 518:protocol.c    **** *                                                                              *
 519:protocol.c    **** * PROCEDURE:                                                                   *
 520:protocol.c    **** *       send_ack                                                               *
 521:protocol.c    **** *                                                                              *
 522:protocol.c    **** * DESCRIPTION:                                                                 *
 523:protocol.c    **** *		Sends a signal to the PC that engine controller is responsive          *
 524:protocol.c    **** *                                                                              *
 525:protocol.c    **** *******************************************************************************/
 526:protocol.c    **** static void send_ack
 527:protocol.c    **** 	(
 528:protocol.c    **** 	void
 529:protocol.c    **** 	)
 530:protocol.c    **** 
 531:protocol.c    **** { 
  27              		.loc 1 531 1 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 00B5     		push	{lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 14, -4
  35 0002 83B0     		sub	sp, sp, #12
  36              	.LCFI1:
  37              		.cfi_def_cfa_offset 16
 532:protocol.c    **** uint8_t response = ACK_OP; 
  38              		.loc 1 532 1 view .LVU1
  39              		.loc 1 532 9 is_stmt 0 view .LVU2
ARM GAS  /tmp/ccWOMrG1.s 			page 11


  40 0004 9523     		movs	r3, #149
  41 0006 8DF80730 		strb	r3, [sp, #7]
 533:protocol.c    **** rs485_transmit( &response, sizeof( response ), RS485_DEFAULT_TIMEOUT );
  42              		.loc 1 533 1 is_stmt 1 view .LVU3
  43 000a 1422     		movs	r2, #20
  44 000c 0121     		movs	r1, #1
  45 000e 0DF10700 		add	r0, sp, #7
  46 0012 FFF7FEFF 		bl	rs485_transmit
  47              	.LVL0:
 534:protocol.c    **** } /* send_no_ack */
  48              		.loc 1 534 1 is_stmt 0 view .LVU4
  49 0016 03B0     		add	sp, sp, #12
  50              	.LCFI2:
  51              		.cfi_def_cfa_offset 4
  52              		@ sp needed
  53 0018 5DF804FB 		ldr	pc, [sp], #4
  54              		.cfi_endproc
  55              	.LFE336:
  57              		.section	.text.protocol_command_handler,"ax",%progbits
  58              		.align	1
  59              		.global	protocol_command_handler
  60              		.syntax unified
  61              		.thumb
  62              		.thumb_func
  64              	protocol_command_handler:
  65              	.LVL1:
  66              	.LFB333:
  80:protocol.c    **** /*------------------------------------------------------------------------------
  67              		.loc 1 80 1 is_stmt 1 view -0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 96
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  80:protocol.c    **** /*------------------------------------------------------------------------------
  71              		.loc 1 80 1 is_stmt 0 view .LVU6
  72 0000 30B5     		push	{r4, r5, lr}
  73              	.LCFI3:
  74              		.cfi_def_cfa_offset 12
  75              		.cfi_offset 4, -12
  76              		.cfi_offset 5, -8
  77              		.cfi_offset 14, -4
  78 0002 99B0     		sub	sp, sp, #100
  79              	.LCFI4:
  80              		.cfi_def_cfa_offset 112
  81 0004 8DF80700 		strb	r0, [sp, #7]
  84:protocol.c    **** uint8_t          sol_state;                   /* State of solenoids           */
  82              		.loc 1 84 1 is_stmt 1 view .LVU7
  85:protocol.c    **** SENSOR_DATA      sensor_data;                 /* Data from engine sensors     */
  83              		.loc 1 85 1 view .LVU8
  86:protocol.c    **** uint8_t          sensor_data_bytes[ sizeof( SENSOR_DATA ) ]; 
  84              		.loc 1 86 1 view .LVU9
  87:protocol.c    **** RS485_STATUS     rs485_status;                /* RS485 return codes           */
  85              		.loc 1 87 1 view .LVU10
  88:protocol.c    **** VALVE_STATUS     valve_status;                /* Valve module return codes    */
  86              		.loc 1 88 1 view .LVU11
  89:protocol.c    **** TANK_SAFE_STATES tanks_state;                 /* State of tank pressures      */
  87              		.loc 1 89 1 view .LVU12
  90:protocol.c    **** VALVE_STATES     valve_states;                /* Open/close state of valves   */
ARM GAS  /tmp/ccWOMrG1.s 			page 12


  88              		.loc 1 90 1 view .LVU13
  91:protocol.c    **** 
  89              		.loc 1 91 1 view .LVU14
  97:protocol.c    **** valve_status  = VALVE_OK;
  90              		.loc 1 97 1 view .LVU15
  91              	.LVL2:
  98:protocol.c    **** valve_states  = 0;
  92              		.loc 1 98 1 view .LVU16
  99:protocol.c    **** sol_state     = 0;
  93              		.loc 1 99 1 view .LVU17
  99:protocol.c    **** sol_state     = 0;
  94              		.loc 1 99 15 is_stmt 0 view .LVU18
  95 0008 0024     		movs	r4, #0
  96 000a 8DF80A40 		strb	r4, [sp, #10]
 100:protocol.c    **** memset( &sensor_data         , 0, sizeof( sensor_data       ) );
  97              		.loc 1 100 1 is_stmt 1 view .LVU19
 100:protocol.c    **** memset( &sensor_data         , 0, sizeof( sensor_data       ) );
  98              		.loc 1 100 15 is_stmt 0 view .LVU20
  99 000e 8DF85E40 		strb	r4, [sp, #94]
 101:protocol.c    **** memset( &sensor_data_bytes[0], 0, sizeof( sensor_data_bytes ) );
 100              		.loc 1 101 1 is_stmt 1 view .LVU21
 101 0012 2825     		movs	r5, #40
 102 0014 2A46     		mov	r2, r5
 103 0016 2146     		mov	r1, r4
 104 0018 0DA8     		add	r0, sp, #52
 105              	.LVL3:
 101:protocol.c    **** memset( &sensor_data_bytes[0], 0, sizeof( sensor_data_bytes ) );
 106              		.loc 1 101 1 is_stmt 0 view .LVU22
 107 001a FFF7FEFF 		bl	memset
 108              	.LVL4:
 102:protocol.c    **** 
 109              		.loc 1 102 1 is_stmt 1 view .LVU23
 110 001e 2A46     		mov	r2, r5
 111 0020 2146     		mov	r1, r4
 112 0022 03A8     		add	r0, sp, #12
 113 0024 FFF7FEFF 		bl	memset
 114              	.LVL5:
 108:protocol.c    ****     {
 115              		.loc 1 108 1 view .LVU24
 116 0028 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 117 002c 9E2B     		cmp	r3, #158
 118 002e 36D8     		bhi	.L3
 119 0030 512B     		cmp	r3, #81
 120 0032 2BD3     		bcc	.L31
 121 0034 513B     		subs	r3, r3, #81
 122 0036 4D2B     		cmp	r3, #77
 123 0038 31D8     		bhi	.L3
 124 003a DFE803F0 		tbb	[pc, r3]
 125              	.L9:
 126 003e 32       		.byte	(.L23-.L9)/2
 127 003f 5F       		.byte	(.L22-.L9)/2
 128 0040 30       		.byte	(.L3-.L9)/2
 129 0041 30       		.byte	(.L3-.L9)/2
 130 0042 30       		.byte	(.L3-.L9)/2
 131 0043 30       		.byte	(.L3-.L9)/2
 132 0044 30       		.byte	(.L3-.L9)/2
 133 0045 30       		.byte	(.L3-.L9)/2
ARM GAS  /tmp/ccWOMrG1.s 			page 13


 134 0046 30       		.byte	(.L3-.L9)/2
 135 0047 30       		.byte	(.L3-.L9)/2
 136 0048 30       		.byte	(.L3-.L9)/2
 137 0049 30       		.byte	(.L3-.L9)/2
 138 004a 30       		.byte	(.L3-.L9)/2
 139 004b 30       		.byte	(.L3-.L9)/2
 140 004c 30       		.byte	(.L3-.L9)/2
 141 004d 30       		.byte	(.L3-.L9)/2
 142 004e 30       		.byte	(.L3-.L9)/2
 143 004f 30       		.byte	(.L3-.L9)/2
 144 0050 30       		.byte	(.L3-.L9)/2
 145 0051 30       		.byte	(.L3-.L9)/2
 146 0052 30       		.byte	(.L3-.L9)/2
 147 0053 30       		.byte	(.L3-.L9)/2
 148 0054 30       		.byte	(.L3-.L9)/2
 149 0055 30       		.byte	(.L3-.L9)/2
 150 0056 30       		.byte	(.L3-.L9)/2
 151 0057 30       		.byte	(.L3-.L9)/2
 152 0058 30       		.byte	(.L3-.L9)/2
 153 0059 30       		.byte	(.L3-.L9)/2
 154 005a 30       		.byte	(.L3-.L9)/2
 155 005b 30       		.byte	(.L3-.L9)/2
 156 005c 30       		.byte	(.L3-.L9)/2
 157 005d 30       		.byte	(.L3-.L9)/2
 158 005e 30       		.byte	(.L3-.L9)/2
 159 005f 30       		.byte	(.L3-.L9)/2
 160 0060 30       		.byte	(.L3-.L9)/2
 161 0061 30       		.byte	(.L3-.L9)/2
 162 0062 30       		.byte	(.L3-.L9)/2
 163 0063 30       		.byte	(.L3-.L9)/2
 164 0064 30       		.byte	(.L3-.L9)/2
 165 0065 30       		.byte	(.L3-.L9)/2
 166 0066 30       		.byte	(.L3-.L9)/2
 167 0067 30       		.byte	(.L3-.L9)/2
 168 0068 30       		.byte	(.L3-.L9)/2
 169 0069 30       		.byte	(.L3-.L9)/2
 170 006a 30       		.byte	(.L3-.L9)/2
 171 006b 30       		.byte	(.L3-.L9)/2
 172 006c 30       		.byte	(.L3-.L9)/2
 173 006d 30       		.byte	(.L3-.L9)/2
 174 006e 30       		.byte	(.L3-.L9)/2
 175 006f 30       		.byte	(.L3-.L9)/2
 176 0070 30       		.byte	(.L3-.L9)/2
 177 0071 30       		.byte	(.L3-.L9)/2
 178 0072 30       		.byte	(.L3-.L9)/2
 179 0073 30       		.byte	(.L3-.L9)/2
 180 0074 30       		.byte	(.L3-.L9)/2
 181 0075 30       		.byte	(.L3-.L9)/2
 182 0076 30       		.byte	(.L3-.L9)/2
 183 0077 30       		.byte	(.L3-.L9)/2
 184 0078 30       		.byte	(.L3-.L9)/2
 185 0079 30       		.byte	(.L3-.L9)/2
 186 007a 30       		.byte	(.L3-.L9)/2
 187 007b 30       		.byte	(.L3-.L9)/2
 188 007c 30       		.byte	(.L3-.L9)/2
 189 007d 77       		.byte	(.L21-.L9)/2
 190 007e 9F       		.byte	(.L20-.L9)/2
ARM GAS  /tmp/ccWOMrG1.s 			page 14


 191 007f A5       		.byte	(.L19-.L9)/2
 192 0080 AB       		.byte	(.L18-.L9)/2
 193 0081 B1       		.byte	(.L17-.L9)/2
 194 0082 30       		.byte	(.L3-.L9)/2
 195 0083 7F       		.byte	(.L16-.L9)/2
 196 0084 B7       		.byte	(.L15-.L9)/2
 197 0085 30       		.byte	(.L3-.L9)/2
 198 0086 BD       		.byte	(.L14-.L9)/2
 199 0087 C3       		.byte	(.L13-.L9)/2
 200 0088 C9       		.byte	(.L12-.L9)/2
 201 0089 CF       		.byte	(.L11-.L9)/2
 202 008a D5       		.byte	(.L10-.L9)/2
 203 008b E6       		.byte	(.L8-.L9)/2
 204              		.p2align 1
 205              	.L31:
 206 008c 012B     		cmp	r3, #1
 207 008e 04D0     		beq	.L6
 208 0090 022B     		cmp	r3, #2
 209 0092 04D1     		bne	.L3
 124:protocol.c    ****         break;
 210              		.loc 1 124 9 view .LVU25
 211 0094 FFF7FEFF 		bl	ping
 212              	.LVL6:
 125:protocol.c    ****         } /* CONNECT_OP */
 213              		.loc 1 125 9 view .LVU26
 214 0098 01E0     		b	.L3
 215              	.L6:
 115:protocol.c    ****         break;
 216              		.loc 1 115 9 view .LVU27
 217 009a FFF7FEFF 		bl	ping
 218              	.LVL7:
 116:protocol.c    ****         } /* PING_OP */
 219              		.loc 1 116 9 view .LVU28
 220              	.L3:
 380:protocol.c    **** 
 221              		.loc 1 380 1 is_stmt 0 view .LVU29
 222 009e 19B0     		add	sp, sp, #100
 223              	.LCFI5:
 224              		.cfi_remember_state
 225              		.cfi_def_cfa_offset 12
 226              		@ sp needed
 227 00a0 30BD     		pop	{r4, r5, pc}
 228              	.LVL8:
 229              	.L23:
 230              	.LCFI6:
 231              		.cfi_restore_state
 134:protocol.c    ****                                       sizeof( subcommand ), 
 232              		.loc 1 134 9 is_stmt 1 view .LVU30
 134:protocol.c    ****                                       sizeof( subcommand ), 
 233              		.loc 1 134 24 is_stmt 0 view .LVU31
 234 00a2 1422     		movs	r2, #20
 235 00a4 0121     		movs	r1, #1
 236 00a6 0DF15F00 		add	r0, sp, #95
 237 00aa FFF7FEFF 		bl	rs485_receive
 238              	.LVL9:
 137:protocol.c    ****             {
 239              		.loc 1 137 9 is_stmt 1 view .LVU32
ARM GAS  /tmp/ccWOMrG1.s 			page 15


 137:protocol.c    ****             {
 240              		.loc 1 137 12 is_stmt 0 view .LVU33
 241 00ae 18B1     		cbz	r0, .L24
 139:protocol.c    ****             break;
 242              		.loc 1 139 13 is_stmt 1 view .LVU34
 243 00b0 0620     		movs	r0, #6
 244              	.LVL10:
 139:protocol.c    ****             break;
 245              		.loc 1 139 13 is_stmt 0 view .LVU35
 246 00b2 FFF7FEFF 		bl	led_set_color
 247              	.LVL11:
 140:protocol.c    ****             }
 248              		.loc 1 140 13 is_stmt 1 view .LVU36
 249 00b6 F2E7     		b	.L3
 250              	.LVL12:
 251              	.L24:
 144:protocol.c    ****         valve_transmit( &subcommand, sizeof( command ), HAL_DEFAULT_TIMEOUT );
 252              		.loc 1 144 9 view .LVU37
 253 00b8 0A22     		movs	r2, #10
 254 00ba 0121     		movs	r1, #1
 255 00bc 0DF10700 		add	r0, sp, #7
 256              	.LVL13:
 144:protocol.c    ****         valve_transmit( &subcommand, sizeof( command ), HAL_DEFAULT_TIMEOUT );
 257              		.loc 1 144 9 is_stmt 0 view .LVU38
 258 00c0 FFF7FEFF 		bl	valve_transmit
 259              	.LVL14:
 145:protocol.c    **** 
 260              		.loc 1 145 9 is_stmt 1 view .LVU39
 261 00c4 0A22     		movs	r2, #10
 262 00c6 0121     		movs	r1, #1
 263 00c8 0DF15F00 		add	r0, sp, #95
 264 00cc FFF7FEFF 		bl	valve_transmit
 265              	.LVL15:
 148:protocol.c    ****             {
 266              		.loc 1 148 9 view .LVU40
 148:protocol.c    ****             {
 267              		.loc 1 148 25 is_stmt 0 view .LVU41
 268 00d0 9DF85F30 		ldrb	r3, [sp, #95]	@ zero_extendqisi2
 148:protocol.c    ****             {
 269              		.loc 1 148 12 view .LVU42
 270 00d4 202B     		cmp	r3, #32
 271 00d6 E2D1     		bne	.L3
 150:protocol.c    ****                                           sizeof( sol_state ), 
 272              		.loc 1 150 13 is_stmt 1 view .LVU43
 150:protocol.c    ****                                           sizeof( sol_state ), 
 273              		.loc 1 150 28 is_stmt 0 view .LVU44
 274 00d8 0A22     		movs	r2, #10
 275 00da 0121     		movs	r1, #1
 276 00dc 0DF15E00 		add	r0, sp, #94
 277 00e0 FFF7FEFF 		bl	valve_receive
 278              	.LVL16:
 153:protocol.c    ****                 {
 279              		.loc 1 153 13 is_stmt 1 view .LVU45
 153:protocol.c    ****                 {
 280              		.loc 1 153 16 is_stmt 0 view .LVU46
 281 00e4 18B1     		cbz	r0, .L25
 155:protocol.c    ****                 break;
ARM GAS  /tmp/ccWOMrG1.s 			page 16


 282              		.loc 1 155 17 is_stmt 1 view .LVU47
 283 00e6 0620     		movs	r0, #6
 284              	.LVL17:
 155:protocol.c    ****                 break;
 285              		.loc 1 155 17 is_stmt 0 view .LVU48
 286 00e8 FFF7FEFF 		bl	led_set_color
 287              	.LVL18:
 156:protocol.c    ****                 }
 288              		.loc 1 156 17 is_stmt 1 view .LVU49
 289 00ec D7E7     		b	.L3
 290              	.LVL19:
 291              	.L25:
 158:protocol.c    ****             }
 292              		.loc 1 158 13 view .LVU50
 293 00ee 0A22     		movs	r2, #10
 294 00f0 0121     		movs	r1, #1
 295 00f2 0DF15E00 		add	r0, sp, #94
 296              	.LVL20:
 158:protocol.c    ****             }
 297              		.loc 1 158 13 is_stmt 0 view .LVU51
 298 00f6 FFF7FEFF 		bl	rs485_transmit
 299              	.LVL21:
 300 00fa D0E7     		b	.L3
 301              	.LVL22:
 302              	.L22:
 169:protocol.c    ****                                       sizeof( subcommand ), 
 303              		.loc 1 169 9 is_stmt 1 view .LVU52
 169:protocol.c    ****                                       sizeof( subcommand ), 
 304              		.loc 1 169 24 is_stmt 0 view .LVU53
 305 00fc 1422     		movs	r2, #20
 306 00fe 0121     		movs	r1, #1
 307 0100 0DF15F00 		add	r0, sp, #95
 308 0104 FFF7FEFF 		bl	rs485_receive
 309              	.LVL23:
 172:protocol.c    ****             {
 310              		.loc 1 172 9 is_stmt 1 view .LVU54
 172:protocol.c    ****             {
 311              		.loc 1 172 12 is_stmt 0 view .LVU55
 312 0108 18B1     		cbz	r0, .L26
 174:protocol.c    ****             break;
 313              		.loc 1 174 13 is_stmt 1 view .LVU56
 314 010a 0620     		movs	r0, #6
 315              	.LVL24:
 174:protocol.c    ****             break;
 316              		.loc 1 174 13 is_stmt 0 view .LVU57
 317 010c FFF7FEFF 		bl	led_set_color
 318              	.LVL25:
 175:protocol.c    ****             }
 319              		.loc 1 175 13 is_stmt 1 view .LVU58
 320 0110 C5E7     		b	.L3
 321              	.LVL26:
 322              	.L26:
 179:protocol.c    ****         valve_transmit( &subcommand, sizeof( command ), HAL_DEFAULT_TIMEOUT );
 323              		.loc 1 179 9 view .LVU59
 324 0112 0A22     		movs	r2, #10
 325 0114 0121     		movs	r1, #1
 326 0116 0DF10700 		add	r0, sp, #7
ARM GAS  /tmp/ccWOMrG1.s 			page 17


 327              	.LVL27:
 179:protocol.c    ****         valve_transmit( &subcommand, sizeof( command ), HAL_DEFAULT_TIMEOUT );
 328              		.loc 1 179 9 is_stmt 0 view .LVU60
 329 011a FFF7FEFF 		bl	valve_transmit
 330              	.LVL28:
 180:protocol.c    ****         break;
 331              		.loc 1 180 9 is_stmt 1 view .LVU61
 332 011e 0A22     		movs	r2, #10
 333 0120 0121     		movs	r1, #1
 334 0122 0DF15F00 		add	r0, sp, #95
 335 0126 FFF7FEFF 		bl	valve_transmit
 336              	.LVL29:
 181:protocol.c    ****         } /* VALVE_OP */
 337              		.loc 1 181 9 view .LVU62
 338 012a B8E7     		b	.L3
 339              	.LVL30:
 340              	.L21:
 190:protocol.c    **** 
 341              		.loc 1 190 9 view .LVU63
 342 012c FFF7FEFF 		bl	send_ack
 343              	.LVL31:
 193:protocol.c    ****         fsm_state = FSM_ABORT_STATE;
 344              		.loc 1 193 9 view .LVU64
 345 0130 FFF7FEFF 		bl	run_abort_state
 346              	.LVL32:
 194:protocol.c    ****         break;
 347              		.loc 1 194 9 view .LVU65
 194:protocol.c    ****         break;
 348              		.loc 1 194 19 is_stmt 0 view .LVU66
 349 0134 384B     		ldr	r3, .L32
 350 0136 0922     		movs	r2, #9
 351 0138 1A70     		strb	r2, [r3]
 195:protocol.c    ****         } /* ABORT_OP */
 352              		.loc 1 195 9 is_stmt 1 view .LVU67
 353 013a B0E7     		b	.L3
 354              	.L16:
 204:protocol.c    **** 
 355              		.loc 1 204 9 view .LVU68
 356 013c FFF7FEFF 		bl	send_ack
 357              	.LVL33:
 207:protocol.c    ****         memcpy( &sensor_data_bytes[0], &sensor_data, sizeof( SENSOR_DATA ) );
 358              		.loc 1 207 9 view .LVU69
 359 0140 0DA8     		add	r0, sp, #52
 360 0142 FFF7FEFF 		bl	sensor_dump
 361              	.LVL34:
 208:protocol.c    **** 
 362              		.loc 1 208 9 view .LVU70
 363 0146 03AD     		add	r5, sp, #12
 364 0148 0DAC     		add	r4, sp, #52
 365 014a 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 366 014c 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 367 014e 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 368 0150 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 369 0152 94E80300 		ldm	r4, {r0, r1}
 370 0156 85E80300 		stm	r5, {r0, r1}
 211:protocol.c    **** 
 371              		.loc 1 211 9 view .LVU71
ARM GAS  /tmp/ccWOMrG1.s 			page 18


 372 015a 0DF10A00 		add	r0, sp, #10
 373 015e FFF7FEFF 		bl	vc_getstate
 374              	.LVL35:
 214:protocol.c    ****                         sizeof( SENSOR_DATA ), 
 375              		.loc 1 214 9 view .LVU72
 376 0162 4FF44872 		mov	r2, #800
 377 0166 2821     		movs	r1, #40
 378 0168 03A8     		add	r0, sp, #12
 379 016a FFF7FEFF 		bl	rs485_transmit
 380              	.LVL36:
 217:protocol.c    ****                         sizeof( valve_states ), 
 381              		.loc 1 217 9 view .LVU73
 382 016e 1422     		movs	r2, #20
 383 0170 0121     		movs	r1, #1
 384 0172 0DF10A00 		add	r0, sp, #10
 385 0176 FFF7FEFF 		bl	rs485_transmit
 386              	.LVL37:
 220:protocol.c    ****         } /* TELREQ_OP */
 387              		.loc 1 220 9 view .LVU74
 388 017a 90E7     		b	.L3
 389              	.L20:
 229:protocol.c    **** 
 390              		.loc 1 229 9 view .LVU75
 391 017c FFF7FEFF 		bl	send_ack
 392              	.LVL38:
 232:protocol.c    ****         break;
 393              		.loc 1 232 9 view .LVU76
 232:protocol.c    ****         break;
 394              		.loc 1 232 19 is_stmt 0 view .LVU77
 395 0180 254B     		ldr	r3, .L32
 396 0182 0222     		movs	r2, #2
 397 0184 1A70     		strb	r2, [r3]
 233:protocol.c    ****         } /* PFPURGE_OP */
 398              		.loc 1 233 9 is_stmt 1 view .LVU78
 399 0186 8AE7     		b	.L3
 400              	.L19:
 242:protocol.c    **** 
 401              		.loc 1 242 9 view .LVU79
 402 0188 FFF7FEFF 		bl	send_ack
 403              	.LVL39:
 245:protocol.c    ****         break;
 404              		.loc 1 245 9 view .LVU80
 245:protocol.c    ****         break;
 405              		.loc 1 245 19 is_stmt 0 view .LVU81
 406 018c 224B     		ldr	r3, .L32
 407 018e 0322     		movs	r2, #3
 408 0190 1A70     		strb	r2, [r3]
 246:protocol.c    ****         } /* CHILL_OP */
 409              		.loc 1 246 9 is_stmt 1 view .LVU82
 410 0192 84E7     		b	.L3
 411              	.L18:
 255:protocol.c    **** 
 412              		.loc 1 255 9 view .LVU83
 413 0194 FFF7FEFF 		bl	send_ack
 414              	.LVL40:
 258:protocol.c    ****         break;
 415              		.loc 1 258 9 view .LVU84
ARM GAS  /tmp/ccWOMrG1.s 			page 19


 258:protocol.c    ****         break;
 416              		.loc 1 258 19 is_stmt 0 view .LVU85
 417 0198 1F4B     		ldr	r3, .L32
 418 019a 0422     		movs	r2, #4
 419 019c 1A70     		strb	r2, [r3]
 259:protocol.c    ****         } /* STANDBY_OP */
 420              		.loc 1 259 9 is_stmt 1 view .LVU86
 421 019e 7EE7     		b	.L3
 422              	.L17:
 268:protocol.c    **** 
 423              		.loc 1 268 9 view .LVU87
 424 01a0 FFF7FEFF 		bl	send_ack
 425              	.LVL41:
 271:protocol.c    ****         break;
 426              		.loc 1 271 9 view .LVU88
 271:protocol.c    ****         break;
 427              		.loc 1 271 19 is_stmt 0 view .LVU89
 428 01a4 1C4B     		ldr	r3, .L32
 429 01a6 0522     		movs	r2, #5
 430 01a8 1A70     		strb	r2, [r3]
 272:protocol.c    ****         } /* FIRE_OP */
 431              		.loc 1 272 9 is_stmt 1 view .LVU90
 432 01aa 78E7     		b	.L3
 433              	.L15:
 281:protocol.c    **** 
 434              		.loc 1 281 9 view .LVU91
 435 01ac FFF7FEFF 		bl	send_ack
 436              	.LVL42:
 284:protocol.c    ****         break;
 437              		.loc 1 284 9 view .LVU92
 284:protocol.c    ****         break;
 438              		.loc 1 284 25 is_stmt 0 view .LVU93
 439 01b0 1A4B     		ldr	r3, .L32+4
 440 01b2 0122     		movs	r2, #1
 441 01b4 1A70     		strb	r2, [r3]
 285:protocol.c    ****         } /* STOPPURGE_OP */
 442              		.loc 1 285 9 is_stmt 1 view .LVU94
 443 01b6 72E7     		b	.L3
 444              	.L14:
 294:protocol.c    ****         break;
 445              		.loc 1 294 9 view .LVU95
 446 01b8 1422     		movs	r2, #20
 447 01ba 0121     		movs	r1, #1
 448 01bc 1648     		ldr	r0, .L32
 449 01be FFF7FEFF 		bl	rs485_transmit
 450              	.LVL43:
 295:protocol.c    ****         } /* HOTFIRE_GETSTATE_OP */
 451              		.loc 1 295 9 view .LVU96
 452 01c2 6CE7     		b	.L3
 453              	.L13:
 304:protocol.c    **** 
 454              		.loc 1 304 9 view .LVU97
 455 01c4 FFF7FEFF 		bl	send_ack
 456              	.LVL44:
 307:protocol.c    ****         break;
 457              		.loc 1 307 9 view .LVU98
 307:protocol.c    ****         break;
ARM GAS  /tmp/ccWOMrG1.s 			page 20


 458              		.loc 1 307 27 is_stmt 0 view .LVU99
 459 01c8 154B     		ldr	r3, .L32+8
 460 01ca 0122     		movs	r2, #1
 461 01cc 1A70     		strb	r2, [r3]
 308:protocol.c    ****         } /* STOP_HOTFIRE_OP */
 462              		.loc 1 308 9 is_stmt 1 view .LVU100
 463 01ce 66E7     		b	.L3
 464              	.L12:
 317:protocol.c    **** 
 465              		.loc 1 317 9 view .LVU101
 466 01d0 FFF7FEFF 		bl	send_ack
 467              	.LVL45:
 320:protocol.c    ****         break;
 468              		.loc 1 320 9 view .LVU102
 320:protocol.c    ****         break;
 469              		.loc 1 320 24 is_stmt 0 view .LVU103
 470 01d4 134B     		ldr	r3, .L32+12
 471 01d6 0122     		movs	r2, #1
 472 01d8 1A70     		strb	r2, [r3]
 321:protocol.c    ****         } /* LOX_PURGE_OP */
 473              		.loc 1 321 9 is_stmt 1 view .LVU104
 474 01da 60E7     		b	.L3
 475              	.L11:
 330:protocol.c    **** 
 476              		.loc 1 330 9 view .LVU105
 477 01dc FFF7FEFF 		bl	send_ack
 478              	.LVL46:
 333:protocol.c    ****         break;
 479              		.loc 1 333 9 view .LVU106
 333:protocol.c    ****         break;
 480              		.loc 1 333 29 is_stmt 0 view .LVU107
 481 01e0 114B     		ldr	r3, .L32+16
 482 01e2 0122     		movs	r2, #1
 483 01e4 1A70     		strb	r2, [r3]
 334:protocol.c    ****         } /* KBOTTLE_CLOSED_OP */
 484              		.loc 1 334 9 is_stmt 1 view .LVU108
 485 01e6 5AE7     		b	.L3
 486              	.L10:
 343:protocol.c    ****             {
 487              		.loc 1 343 9 view .LVU109
 343:protocol.c    ****             {
 488              		.loc 1 343 14 is_stmt 0 view .LVU110
 489 01e8 104B     		ldr	r3, .L32+20
 490 01ea 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 343:protocol.c    ****             {
 491              		.loc 1 343 12 view .LVU111
 492 01ec 4BB1     		cbz	r3, .L27
 345:protocol.c    ****             }
 493              		.loc 1 345 13 is_stmt 1 view .LVU112
 345:protocol.c    ****             }
 494              		.loc 1 345 25 is_stmt 0 view .LVU113
 495 01ee 0123     		movs	r3, #1
 496 01f0 8DF80B30 		strb	r3, [sp, #11]
 497              	.L28:
 353:protocol.c    ****         break;
 498              		.loc 1 353 9 is_stmt 1 view .LVU114
 499 01f4 1422     		movs	r2, #20
ARM GAS  /tmp/ccWOMrG1.s 			page 21


 500 01f6 0121     		movs	r1, #1
 501 01f8 0DF10B00 		add	r0, sp, #11
 502 01fc FFF7FEFF 		bl	rs485_transmit
 503              	.LVL47:
 354:protocol.c    ****         }
 504              		.loc 1 354 9 view .LVU115
 505 0200 4DE7     		b	.L3
 506              	.L27:
 349:protocol.c    ****             }
 507              		.loc 1 349 13 view .LVU116
 349:protocol.c    ****             }
 508              		.loc 1 349 25 is_stmt 0 view .LVU117
 509 0202 0223     		movs	r3, #2
 510 0204 8DF80B30 		strb	r3, [sp, #11]
 511 0208 F4E7     		b	.L28
 512              	.L8:
 363:protocol.c    **** 
 513              		.loc 1 363 9 is_stmt 1 view .LVU118
 514 020a FFF7FEFF 		bl	send_ack
 515              	.LVL48:
 366:protocol.c    ****         break;
 516              		.loc 1 366 9 view .LVU119
 366:protocol.c    ****         break;
 517              		.loc 1 366 19 is_stmt 0 view .LVU120
 518 020e 024B     		ldr	r3, .L32
 519 0210 0822     		movs	r2, #8
 520 0212 1A70     		strb	r2, [r3]
 367:protocol.c    ****         } /* KBOTTLE_CLOSED_OP */
 521              		.loc 1 367 9 is_stmt 1 view .LVU121
 377:protocol.c    ****     } 
 522              		.loc 1 377 9 view .LVU122
 380:protocol.c    **** 
 523              		.loc 1 380 1 is_stmt 0 view .LVU123
 524 0214 43E7     		b	.L3
 525              	.L33:
 526 0216 00BF     		.align	2
 527              	.L32:
 528 0218 00000000 		.word	fsm_state
 529 021c 00000000 		.word	stop_purge_flag
 530 0220 00000000 		.word	stop_hotfire_flag
 531 0224 00000000 		.word	lox_purge_flag
 532 0228 00000000 		.word	kbottle_closed_flag
 533 022c 00000000 		.word	tanks_safe_flag
 534              		.cfi_endproc
 535              	.LFE333:
 537              		.section	.text.protocol_send_frame,"ax",%progbits
 538              		.align	1
 539              		.global	protocol_send_frame
 540              		.syntax unified
 541              		.thumb
 542              		.thumb_func
 544              	protocol_send_frame:
 545              	.LFB334:
 396:protocol.c    **** /*------------------------------------------------------------------------------
 546              		.loc 1 396 1 is_stmt 1 view -0
 547              		.cfi_startproc
 548              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/ccWOMrG1.s 			page 22


 549              		@ frame_needed = 0, uses_anonymous_args = 0
 550 0000 00B5     		push	{lr}
 551              	.LCFI7:
 552              		.cfi_def_cfa_offset 4
 553              		.cfi_offset 14, -4
 554 0002 83B0     		sub	sp, sp, #12
 555              	.LCFI8:
 556              		.cfi_def_cfa_offset 16
 557 0004 0190     		str	r0, [sp, #4]
 403:protocol.c    **** #endif
 558              		.loc 1 403 5 view .LVU125
 413:protocol.c    **** #endif
 559              		.loc 1 413 5 view .LVU126
 560              	.LVL49:
 433:protocol.c    ****     if ( rf_status == RF_TIMEOUT )
 561              		.loc 1 433 5 view .LVU127
 433:protocol.c    ****     if ( rf_status == RF_TIMEOUT )
 562              		.loc 1 433 17 is_stmt 0 view .LVU128
 563 0006 0321     		movs	r1, #3
 564 0008 01A8     		add	r0, sp, #4
 565 000a FFF7FEFF 		bl	rf_xbee_transmit
 566              	.LVL50:
 434:protocol.c    ****         {
 567              		.loc 1 434 5 is_stmt 1 view .LVU129
 434:protocol.c    ****         {
 568              		.loc 1 434 8 is_stmt 0 view .LVU130
 569 000e 0228     		cmp	r0, #2
 570 0010 03D0     		beq	.L36
 438:protocol.c    ****         {
 571              		.loc 1 438 10 is_stmt 1 view .LVU131
 438:protocol.c    ****         {
 572              		.loc 1 438 13 is_stmt 0 view .LVU132
 573 0012 20B9     		cbnz	r0, .L39
 574              	.LVL51:
 575              	.L35:
 445:protocol.c    **** 
 576              		.loc 1 445 1 view .LVU133
 577 0014 03B0     		add	sp, sp, #12
 578              	.LCFI9:
 579              		.cfi_remember_state
 580              		.cfi_def_cfa_offset 4
 581              		@ sp needed
 582 0016 5DF804FB 		ldr	pc, [sp], #4
 583              	.LVL52:
 584              	.L36:
 585              	.LCFI10:
 586              		.cfi_restore_state
 436:protocol.c    ****         }
 587              		.loc 1 436 16 view .LVU134
 588 001a 0120     		movs	r0, #1
 589              	.LVL53:
 436:protocol.c    ****         }
 590              		.loc 1 436 16 view .LVU135
 591 001c FAE7     		b	.L35
 592              	.LVL54:
 593              	.L39:
 440:protocol.c    ****         }
ARM GAS  /tmp/ccWOMrG1.s 			page 23


 594              		.loc 1 440 16 view .LVU136
 595 001e 0120     		movs	r0, #1
 596              	.LVL55:
 440:protocol.c    ****         }
 597              		.loc 1 440 16 view .LVU137
 598 0020 F8E7     		b	.L35
 599              		.cfi_endproc
 600              	.LFE334:
 602              		.section	.text.protocol_get_frame,"ax",%progbits
 603              		.align	1
 604              		.global	protocol_get_frame
 605              		.syntax unified
 606              		.thumb
 607              		.thumb_func
 609              	protocol_get_frame:
 610              	.LVL56:
 611              	.LFB335:
 461:protocol.c    **** /*------------------------------------------------------------------------------
 612              		.loc 1 461 1 is_stmt 1 view -0
 613              		.cfi_startproc
 614              		@ args = 0, pretend = 0, frame = 0
 615              		@ frame_needed = 0, uses_anonymous_args = 0
 461:protocol.c    **** /*------------------------------------------------------------------------------
 616              		.loc 1 461 1 is_stmt 0 view .LVU139
 617 0000 08B5     		push	{r3, lr}
 618              	.LCFI11:
 619              		.cfi_def_cfa_offset 8
 620              		.cfi_offset 3, -8
 621              		.cfi_offset 14, -4
 468:protocol.c    **** #endif
 622              		.loc 1 468 5 is_stmt 1 view .LVU140
 478:protocol.c    **** #endif
 623              		.loc 1 478 5 view .LVU141
 624              	.LVL57:
 498:protocol.c    ****     if ( rf_status == RF_TIMEOUT )
 625              		.loc 1 498 5 view .LVU142
 498:protocol.c    ****     if ( rf_status == RF_TIMEOUT )
 626              		.loc 1 498 17 is_stmt 0 view .LVU143
 627 0002 0321     		movs	r1, #3
 628 0004 FFF7FEFF 		bl	rf_xbee_receive
 629              	.LVL58:
 499:protocol.c    ****         {
 630              		.loc 1 499 5 is_stmt 1 view .LVU144
 499:protocol.c    ****         {
 631              		.loc 1 499 8 is_stmt 0 view .LVU145
 632 0008 0228     		cmp	r0, #2
 633 000a 01D0     		beq	.L42
 503:protocol.c    ****         {
 634              		.loc 1 503 10 is_stmt 1 view .LVU146
 503:protocol.c    ****         {
 635              		.loc 1 503 13 is_stmt 0 view .LVU147
 636 000c 10B9     		cbnz	r0, .L45
 637              	.LVL59:
 638              	.L41:
 510:protocol.c    **** 
 639              		.loc 1 510 1 view .LVU148
 640 000e 08BD     		pop	{r3, pc}
ARM GAS  /tmp/ccWOMrG1.s 			page 24


 641              	.LVL60:
 642              	.L42:
 501:protocol.c    ****         }
 643              		.loc 1 501 16 view .LVU149
 644 0010 0120     		movs	r0, #1
 645              	.LVL61:
 501:protocol.c    ****         }
 646              		.loc 1 501 16 view .LVU150
 647 0012 FCE7     		b	.L41
 648              	.LVL62:
 649              	.L45:
 505:protocol.c    ****         }
 650              		.loc 1 505 16 view .LVU151
 651 0014 0120     		movs	r0, #1
 652              	.LVL63:
 505:protocol.c    ****         }
 653              		.loc 1 505 16 view .LVU152
 654 0016 FAE7     		b	.L41
 655              		.cfi_endproc
 656              	.LFE335:
 658              		.text
 659              	.Letext0:
 660              		.file 2 "/usr/lib/gcc/arm-none-eabi/12.2.1/include/stddef.h"
 661              		.file 3 "/usr/lib/gcc/arm-none-eabi/12.2.1/include/stdint.h"
 662              		.file 4 "../../../mod/sensor/sensor.h"
 663              		.file 5 "main.h"
 664              		.file 6 "valve_control.h"
 665              		.file 7 "protocol.h"
 666              		.file 8 "../../../mod/led/led.h"
 667              		.file 9 "../../../mod/rs485/rs485.h"
 668              		.file 10 "../../../mod/valve/valve.h"
 669              		.file 11 "../../../mod/wireless/wireless.h"
 670              		.file 12 "/usr/include/newlib/string.h"
 671              		.file 13 "../../../mod/commands/commands.h"
 672              		.file 14 "<built-in>"
ARM GAS  /tmp/ccWOMrG1.s 			page 25


DEFINED SYMBOLS
                            *ABS*:0000000000000000 protocol.c
     /tmp/ccWOMrG1.s:20     .text.send_ack:0000000000000000 $t
     /tmp/ccWOMrG1.s:25     .text.send_ack:0000000000000000 send_ack
     /tmp/ccWOMrG1.s:58     .text.protocol_command_handler:0000000000000000 $t
     /tmp/ccWOMrG1.s:64     .text.protocol_command_handler:0000000000000000 protocol_command_handler
     /tmp/ccWOMrG1.s:126    .text.protocol_command_handler:000000000000003e $d
     /tmp/ccWOMrG1.s:204    .text.protocol_command_handler:000000000000008c $t
     /tmp/ccWOMrG1.s:528    .text.protocol_command_handler:0000000000000218 $d
     /tmp/ccWOMrG1.s:538    .text.protocol_send_frame:0000000000000000 $t
     /tmp/ccWOMrG1.s:544    .text.protocol_send_frame:0000000000000000 protocol_send_frame
     /tmp/ccWOMrG1.s:603    .text.protocol_get_frame:0000000000000000 $t
     /tmp/ccWOMrG1.s:609    .text.protocol_get_frame:0000000000000000 protocol_get_frame

UNDEFINED SYMBOLS
rs485_transmit
memset
ping
rs485_receive
led_set_color
valve_transmit
valve_receive
run_abort_state
sensor_dump
vc_getstate
fsm_state
stop_purge_flag
stop_hotfire_flag
lox_purge_flag
kbottle_closed_flag
tanks_safe_flag
rf_xbee_transmit
rf_xbee_receive
